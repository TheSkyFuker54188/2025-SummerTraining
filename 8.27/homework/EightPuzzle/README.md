# 八数码问题求解器

## 项目简介

本项目是中国人民大学信息学院综合设计2025年暑期小学期作业，实现了八数码问题的求解算法。项目使用C++语言编写，实现了广度优先搜索(BFS)和深度优先搜索(DFS)两种算法，并提供了可视化界面展示求解过程。

## 问题描述

八数码问题是一个经典的状态空间搜索问题：

- 在3×3的棋盘上，放置数字为1-8的8个棋牌，还有一个空格
- 只能通过棋牌向空格的移动来改变棋盘的布局
- 目标是从给定的初始布局，通过移动棋牌，达到目标布局（通常是有序排列）

## 项目功能

1. 支持6种不同难度的初始棋局状态
2. 分别实现了广度优先搜索(BFS)和深度优先搜索(DFS)算法
3. 可视化展示搜索过程和解决方案
4. 具有友好的用户界面，支持多种交互方式
5. 支持Windows和Linux平台

## 项目结构

```
EightPuzzle/
├── src/              # 源代码目录
│   ├── EightPuzzle.h       # 头文件，定义状态类和搜索算法
│   ├── EightPuzzleState.cpp # 状态类实现
│   ├── EightPuzzleSolver.cpp # 求解算法实现
│   ├── main.cpp      # 主程序，包含用户界面和可视化
│   ├── build.bat     # Windows编译脚本
│   └── build.sh      # Linux编译脚本
└── README.md         # 项目说明文档
```

## 算法说明

### 状态表示

八数码问题的状态用3×3的矩阵表示，其中0表示空格。

### 操作定义

有四种基本操作：空格向上、下、左、右移动（等效于数字向下、上、右、左移动）。

### 广度优先搜索(BFS)

- 使用队列存储待扩展的状态
- 按照状态被发现的顺序依次扩展
- 总是先搜索离初始状态最近的状态
- 能保证找到最短路径（最少步数）的解
- 空间复杂度较高

### 深度优先搜索(DFS)

- 使用栈存储待扩展的状态
- 尽可能深入地搜索状态空间
- 可能找不到最短路径
- 空间复杂度较低

### 可解性判断

不是所有的八数码初始状态都能通过移动变成目标状态。我们使用逆序数来判断两个状态是否可达：
- 将状态表示为一个序列（从左到右，从上到下，忽略空格）
- 计算序列中的逆序数（逆序对的数量）
- 两个状态的逆序数奇偶性相同时，它们才是可达的

## 编译与运行

### Windows

```
cd src
build.bat
```

### Linux

```
cd src
chmod +x build.sh
./build.sh
```

## 使用说明

1. 运行程序后，选择初始状态（1-6）
2. 选择搜索算法（BFS或DFS）
3. 程序会显示搜索过程和最终解决方案
4. 解决方案包括每一步的棋盘状态和移动方向

## 示例输出

程序会依次打印出解决方案中的每个状态，例如：

```
Step 0:
1 2 3
4 5 6
0 7 8

动作：上

Step 1:
1 2 3
0 5 6
4 7 8

...
```

## 注意事项

- DFS算法可能需要较长时间才能找到解决方案
- 对于复杂的初始状态，BFS通常更快找到解决方案
- 程序使用了ANSI颜色代码进行可视化，在某些终端可能无法正常显示 