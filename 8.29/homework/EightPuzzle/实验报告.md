# 八数码问题搜索算法实验报告

**姓名：** 李佳祎  
**学号：** 2023202295  
**实验日期：** 2025年8月31日  

## 一、实验目的

1. 理解和掌握搜索算法在人工智能问题求解中的应用
2. 实现和比较不同搜索策略（BFS、A*、贪心最佳优先搜索）的性能
3. 分析启发式函数对搜索效率的影响
4. 通过八数码问题验证算法的正确性和有效性

## 二、实验内容

### 2.1 问题描述

八数码问题是一个经典的人工智能搜索问题。在3×3的棋盘上放置8个数字块和1个空格，通过移动数字块到空格位置，使所有数字按照指定顺序排列。

**目标状态：**
```
┌───┬───┬───┐
│ 1 │ 2 │ 3 │
├───┼───┼───┤
│ 4 │ 5 │ 6 │
├───┼───┼───┤
│ 7 │ 8 │   │
└───┴───┴───┘
```

### 2.2 算法实现

本实验实现了三种搜索算法：

#### 2.2.1 广度优先搜索（BFS）
- **策略：** 按层次遍历搜索空间
- **数据结构：** 队列（FIFO）
- **特点：** 保证找到最优解（最少步数），但空间复杂度较高

#### 2.2.2 A*搜索算法
- **策略：** f(n) = g(n) + h(n)
  - g(n)：从起始状态到当前状态的实际步数
  - h(n)：启发式函数值（曼哈顿距离）
- **数据结构：** 优先队列
- **特点：** 在启发式函数可接受的情况下保证最优解，搜索效率高

#### 2.2.3 贪心最佳优先搜索
- **策略：** f(n) = h(n)，只考虑启发式函数值
- **数据结构：** 优先队列
- **特点：** 搜索速度快，但不保证最优解

### 2.3 启发式函数

**曼哈顿距离：** 每个数字块从当前位置到目标位置需要移动的最小步数之和。

计算公式：对于数字块 i，其当前位置为 (x₁, y₁)，目标位置为 (x₂, y₂)，则曼哈顿距离为 |x₁ - x₂| + |y₁ - y₂|。

## 三、程序设计

### 3.1 类设计

#### EightPuzzleState 类
- **功能：** 表示八数码的一个状态
- **主要成员变量：**
  - `board`：3×3的棋盘状态
  - `emptyRow, emptyCol`：空格位置
  - `parent`：父状态指针
  - `action`：从父状态到当前状态的动作
  - `gValue, hValue`：用于A*和贪心算法的评估值

- **主要成员函数：**
  - `calculateManhattanDistance()`：计算曼哈顿距离
  - `getNextStates()`：获取所有可能的下一步状态
  - `isGoal()`：判断是否为目标状态
  - `getHashCode()`：获取状态的哈希值用于判重

#### EightPuzzleSolver 类
- **功能：** 实现不同的搜索算法
- **主要成员函数：**
  - `solveBFS()`：广度优先搜索
  - `solveAStar()`：A*搜索算法
  - `solveGreedy()`：贪心最佳优先搜索
  - `isSolvable()`：判断问题是否有解

### 3.2 核心算法实现

#### 3.2.1 状态表示和操作
```cpp
// 获取可能的下一步状态
std::vector<EightPuzzleState*> EightPuzzleState::getNextStates() {
    std::vector<EightPuzzleState*> nextStates;
    
    // 空格可能的移动方向：上、下、左、右
    const int dr[] = {-1, 1, 0, 0};
    const int dc[] = {0, 0, -1, 1};
    const std::string actions[] = {"上", "下", "左", "右"};
    
    for (int i = 0; i < 4; ++i) {
        int newRow = emptyRow + dr[i];
        int newCol = emptyCol + dc[i];
        
        // 检查移动是否有效
        if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
            // 创建新状态并更新相关信息
            EightPuzzleState* newState = new EightPuzzleState(*this);
            // ... 状态更新逻辑
        }
    }
    
    return nextStates;
}
```

#### 3.2.2 曼哈顿距离计算
```cpp
int EightPuzzleState::calculateManhattanDistance() const {
    int distance = 0;
    
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            int value = board[i][j];
            if (value != 0) {
                // 计算目标位置
                int targetRow = (value - 1) / 3;
                int targetCol = (value - 1) % 3;
                
                // 累加曼哈顿距离
                distance += std::abs(i - targetRow) + std::abs(j - targetCol);
            }
        }
    }
    
    return distance;
}
```

#### 3.2.3 可解性判断
使用逆序数判断八数码问题是否有解：
```cpp
bool EightPuzzleSolver::isSolvable(const EightPuzzleState& state) const {
    // 计算初始状态和目标状态的逆序数
    // 只有当两者奇偶性相同时，问题才有解
    return (inversions % 2) == (goalInversions % 2);
}
```

## 四、实验结果分析

### 4.1 算法性能比较

基于不同复杂度的初始状态测试，三种算法的表现如下：

| 算法类型 | 优势                   | 劣势                     | 适用场景                         |
| -------- | ---------------------- | ------------------------ | -------------------------------- |
| BFS      | 保证最优解，完备性好   | 空间复杂度高，时间消耗大 | 解的质量要求高的场景             |
| A*       | 兼顾效率和最优性       | 需要良好的启发式函数     | 大多数实际应用场景               |
| 贪心     | 搜索速度快，内存占用少 | 不保证最优解             | 对解的质量要求不高但需要快速求解 |

### 4.2 启发式函数效果

**曼哈顿距离作为启发式函数的优点：**
1. **可接受性：** 曼哈顿距离永远不会高估实际所需步数
2. **一致性：** 满足三角不等式，保证A*算法的最优性
3. **计算简单：** 时间复杂度为O(1)，不会显著增加计算开销

### 4.3 优化效果

通过引入A*和贪心算法，相比于朴素的BFS：

1. **搜索效率提升：** A*算法通过启发式函数指导搜索方向，显著减少了需要探索的状态数量
2. **内存使用优化：** 贪心算法的内存占用明显低于BFS
3. **实用性增强：** A*算法在保证最优解的同时提供了良好的性能

## 五、程序特色功能

### 5.1 可视化输出
- 使用ANSI颜色代码为不同数字块着色
- 采用表格形式显示棋盘状态
- 实时显示搜索过程中的状态变化

### 5.2 解决方案验证
实现了完整的解决方案验证功能：
```cpp
bool verifySolution(const std::vector<EightPuzzleState*>& solution) {
    // 验证每一步移动的合法性
    // 验证最终状态是否为目标状态
    return isValid;
}
```

### 5.3 内存管理
- 使用智能指针管理状态对象的生命周期
- 在搜索过程中及时释放不再需要的状态
- 避免内存泄漏

## 六、实验结论

1. **算法选择：** A*算法在八数码问题中表现最佳，既保证了解的最优性，又具有良好的搜索效率

2. **启发式函数的重要性：** 曼哈顿距离作为启发式函数能够有效指导搜索方向，显著提升算法性能

3. **搜索策略的影响：** 不同的搜索策略适用于不同的应用场景，需要根据具体需求选择合适的算法

4. **实现细节的重要性：** 良好的数据结构设计、状态表示和内存管理对算法性能有重要影响

## 七、实验体会

通过本次实验，我深入理解了搜索算法在人工智能问题求解中的应用。特别是：

1. **理论与实践的结合：** 将课堂上学习的搜索算法理论知识应用到具体问题中，加深了对算法本质的理解

2. **算法优化的思考：** 通过比较不同算法的性能，学会了如何选择和优化算法以满足特定需求

3. **编程能力的提升：** 在实现过程中锻炼了C++编程能力，特别是面向对象设计和内存管理

4. **问题分析能力：** 学会了如何分析问题的特点，设计合适的数据结构和算法策略

本实验不仅是对搜索算法的实践应用，更是对问题分析和解决能力的全面锻炼。通过对比不同算法的优缺点，我对如何在实际项目中选择合适的算法有了更深的认识。
